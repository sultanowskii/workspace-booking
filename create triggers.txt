CREATE OR REPLACE FUNCTION check_meeting_room_booking_times()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.end_time <= NEW.start_time THEN
    RAISE EXCEPTION 'End time must be after start time';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_meeting_room_booking_times_insert
BEFORE INSERT ON meeting_room_booking
FOR EACH ROW
EXECUTE PROCEDURE check_meeting_room_booking_times();


CREATE OR REPLACE FUNCTION check_meeting_room_booking_overlap()
RETURNS TRIGGER AS $$
DECLARE
  overlapping_booking RECORD;
BEGIN
  -- Check for overlaps with existing bookings for the same meeting room on the same day.
  SELECT INTO overlapping_booking
    *
  FROM meeting_rooms_booking
  WHERE meeting_rooms_id = NEW.meeting_rooms_id
    AND _date = NEW._date
    AND (
      (NEW.start_time < end_time AND NEW.end_time > start_time) -- Overlaps in the middle
      OR (NEW.start_time < start_time AND NEW.end_time > start_time) -- Starts before, ends within
      OR (NEW.start_time < end_time AND NEW.end_time > end_time) -- Starts within, ends after
    );

  IF FOUND THEN
    RAISE EXCEPTION 'Meeting room booking overlaps with existing booking for meeting room ID: % on date: %', NEW.meeting_rooms_id, NEW._date;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER check_meeting_room_booking_overlap_trigger
BEFORE INSERT ON meeting_rooms_booking
FOR EACH ROW
EXECUTE PROCEDURE check_meeting_room_booking_overlap();

CREATE OR REPLACE FUNCTION check_workplace_booking_overlap()
RETURNS TRIGGER AS $$
DECLARE
  overlapping_booking RECORD;
BEGIN
  SELECT INTO overlapping_booking
    *
  FROM workplaces_booking
  WHERE workplaces_id = NEW.workplaces_id
    AND _date = NEW._date;

  IF FOUND THEN
    RAISE EXCEPTION 'Workplace is already booked for the specified date.';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_workplace_booking_overlap_trigger
BEFORE INSERT ON workplaces_booking
FOR EACH ROW
EXECUTE PROCEDURE check_workplace_booking_overlap();

CREATE OR REPLACE FUNCTION check_room_walls_closed()
RETURNS TRIGGER AS $$
DECLARE
    room_id INTEGER;
    points INTEGER;
    x1 double precision;
    y1 double precision;
    x2 double precision;
    y2 double precision;
BEGIN
    room_id := NEW.rooms_id;
	SELECT count(*) INTO points FROM room_walls WHERE rooms_id = room_id;
    IF points = 0 THEN
        RETURN NEW;
    END IF;
    SELECT x1, y1, x2, y2 INTO x1, y1, x2, y2
	FROM room_walls
	WHERE rooms_id = room_id
	ORDER BY id DESC
	LIMIT 1;
    IF x1 <> (SELECT x1 FROM room_walls WHERE rooms_id = room_id ORDER BY id ASC LIMIT 1) OR y1 <> (SELECT y1 FROM room_walls WHERE rooms_id = room_id ORDER BY id ASC LIMIT 1) THEN
        RAISE EXCEPTION 'Room walls do not form a closed polygon (first and last points do not match).';
    END IF;
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_room_walls_closed_trigger
BEFORE INSERT OR UPDATE ON room_walls
FOR EACH ROW
EXECUTE PROCEDURE check_room_walls_closed();



CREATE EXTENSION postgis;
ALTER TABLE workplaces_visual ADD COLUMN geom geometry(Polygon,4326);
ALTER TABLE meeting_rooms_visual ADD COLUMN geom geometry(Polygon,4326);
ALTER TABLE room_walls ADD COLUMN geom geometry(Polygon,4326);


UPDATE workplaces_visual SET geom = ST_MakePolygon(ST_MakeLine(ARRAY[ST_MakePoint(x, y), ST_MakePoint(x + width, y), ST_MakePoint(x + width, y + height), ST_MakePoint(x, y + height), ST_MakePoint(x,y)]));
UPDATE meeting_rooms_visual SET geom = ST_MakePolygon(ST_MakeLine(ARRAY[ST_MakePoint(x, y), ST_MakePoint(x + width, y), ST_MakePoint(x + width, y + height), ST_MakePoint(x, y + height), ST_MakePoint(x,y)]));
UPDATE room_walls
SET geom = ST_MakePolygon(ST_MakeLine(ARRAY[ST_MakePoint(x1, y1), ST_MakePoint(x2, y1), ST_MakePoint(x2, y2), ST_MakePoint(x1, y2), ST_MakePoint(x1, y1)]));


CREATE OR REPLACE FUNCTION check_geometry_intersections()
RETURNS TRIGGER AS $$
DECLARE
    target_geom geometry;
BEGIN
    IF TG_TABLE_NAME = 'workplaces_visual' THEN
        SELECT geom INTO target_geom FROM workplaces_visual WHERE id = NEW.workplaces_id;
    ELSIF TG_TABLE_NAME = 'meeting_rooms_visual' THEN
        SELECT geom INTO target_geom FROM meeting_rooms_visual WHERE meeting_rooms_id = NEW.meeting_rooms_id;
    END IF;


    IF TG_TABLE_NAME = 'workplaces_visual' THEN
        IF EXISTS (SELECT 1 FROM workplaces_visual WHERE id != NEW.workplaces_id AND ST_Intersects(geom, target_geom)) THEN
            RAISE EXCEPTION 'Workplace overlaps with another workplace.';
        END IF;
        IF EXISTS (SELECT 1 FROM meeting_rooms_visual WHERE ST_Intersects(geom, target_geom)) THEN
            RAISE EXCEPTION 'Workplace overlaps with a meeting room.';
        END IF;
        IF EXISTS (SELECT 1 FROM room_walls WHERE ST_Intersects(geom, target_geom)) THEN
            RAISE EXCEPTION 'Workplace overlaps with room walls.';
        END IF;
    ELSIF TG_TABLE_NAME = 'meeting_rooms_visual' THEN
        IF EXISTS (SELECT 1 FROM meeting_rooms_visual WHERE meeting_rooms_id != NEW.meeting_rooms_id AND ST_Intersects(geom, target_geom)) THEN
            RAISE EXCEPTION 'Meeting room overlaps with another meeting room.';
        END IF;
        IF EXISTS (SELECT 1 FROM room_walls WHERE ST_Intersects(geom, target_geom)) THEN
            RAISE EXCEPTION 'Meeting room overlaps with room walls.';
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER check_geometry_intersections_trigger
BEFORE INSERT OR UPDATE ON workplaces_visual
FOR EACH ROW
EXECUTE PROCEDURE check_geometry_intersections();

CREATE TRIGGER check_geometry_intersections_trigger
BEFORE INSERT OR UPDATE ON meeting_rooms_visual
FOR EACH ROW
EXECUTE PROCEDURE check_geometry_intersections();


CREATE OR REPLACE FUNCTION check_workplace_room_overlap()
RETURNS TRIGGER AS $$
DECLARE
  overlapping_room RECORD;
BEGIN
  SELECT INTO overlapping_room geom FROM room_walls WHERE rooms_id = (SELECT rooms_id FROM workplaces WHERE id = NEW.workplaces_id) AND ST_Intersects(NEW.geom, geom);
  IF FOUND THEN
    RAISE EXCEPTION 'Workplace overlaps with a room wall.';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_workplace_room_overlap_trigger
BEFORE INSERT OR UPDATE ON workplaces_visual
FOR EACH ROW
EXECUTE PROCEDURE check_workplace_room_overlap();


CREATE OR REPLACE FUNCTION check_meeting_room_overlap()
RETURNS TRIGGER AS $$
DECLARE
  overlapping_room RECORD;
BEGIN
  SELECT INTO overlapping_room geom FROM room_walls WHERE rooms_id = (SELECT rooms_id FROM meeting_rooms WHERE id = NEW.meeting_rooms_id) AND ST_Intersects(NEW.geom, geom);
  IF FOUND THEN
    RAISE EXCEPTION 'Meeting room overlaps with a room wall.';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_meeting_room_overlap_trigger
BEFORE INSERT OR UPDATE ON meeting_rooms_visual
FOR EACH ROW
EXECUTE PROCEDURE check_meeting_room_overlap();
